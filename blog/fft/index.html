<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Fast Fourier Transform</title>
		<link rel="stylesheet" href="prism.css">
		<link rel="stylesheet" href="../style.css">
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				tex2jax: {
					inlineMath: [['$','$']],
					displayMath: [['$$','$$']],
					processEscapes: true
				}
			});
		</script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
		<script src="prism.js"></script>
	</head>

	<body>
		<div id="title">The Fast Fourier Transform in Competitive Programming</div>

		<div id="preamble">
				$$
				\newcommand{\om}{\omega}
				$$
		</div>

		<div id="toc">
			<div class="heading">Table of Contents</div>
			<ul>
				<li><a href="#toc0">Introduction</a></li>
				<li><a href="#toc1">Multiplying Polynomials</a></li>
				<li><a href="#toc2">Sampling and Interpolating</a></li>
				<li><a href="#toc3">Speedup Overview</a></li>
				<li><a href="#toc4">Primitive Roots of Unity</a></li>
			</ul>
		</div>

		<div id="main">

			<div id="toc0" class="section">
				<div class="heading">Introduction</div>
				<div class="subsection">

					<p>
						In competitive programming, the Fast Fourier Transform is a technique that speeds up polynomial multiplication from $O(N^2)$ to $O( N \log N)$. In this article, we will explore the basic concepts behind this speedup and its implementation and applications.
					</p>
				</div>
			</div>

			<div id="toc1" class="section">
				<div class="heading">Multiplying Polynomials</div>
				<div class="subsection">

					<p>
						First, let's recap what a polynomial is:
					</p>

					<div class="block">
						<div class="block-heading">Defintion</div>
A polynomial $f(x)$ of degree $n$ is defined as $$f(x) = a_0 + a_1x + a_2x^2 + \dots + a_nx^n$$
where $a_0, \dots, a_n$ are numbers.
					</div>

					<p>
						It's common to include the restriction $a_n \neq 0$, but for later convenience, we won't introduce this restriction.
					</p>

					<p>
						We can multiply polynomials to get a new polynomial. Suppose $f(x) = a_0 + a_1 + \dots + a_nx^n$ and $g(x) = b_0 + b_1 + \dots + b_nx^n$ are both polynomials of degree $n$. Let $h(x) = f(x)g(x)$ be their product. We can calculate $h(x)$ by distributing and collecting the terms:
					</p>

					<p>
						$$\begin{align} h(x) &= f(x)g(x)\\&=(a_0 + a_1x + \dots + a_nx^n)(b_0 + b_1x + \dots + b_nx^n)\\&= \sum_{i = 0}^n\sum_{j = 0}^n a_ib_jx^{i+j} \end{align}$$
					</p>

					<p>
						The product $h(x) = f(x)g(x) = c_0 + c_1x + \dots + c_{2n}x^{2n}$ is a polynomial of degree $2n$. We can find the $k$-th coefficient $c_k$ for all $0 \leq k \leq 2n$ by adding all $a_ib_j$ such that $i + j = k$. To do this, we loop thourgh all $i$ from 0 to $k$ inclusive and set $j = k - i$.
					</p>

					<div class="block">
						<div class="block-heading">Polynomial Mutliplication Formula</div>
If $$\begin{align}f(x) &= a_0 + a_1x + \dots + a_nx^n\\g(x) &= b_0 + b_1x + \dots + a_nx^n \\h(x) = f(x)g(x) &= c_0 + c_1x + \dots + c_{2n}x^{2n}\end{align}$$then for all $0 \leq k \leq 2n$,
$$c_k = \sum_{i = 0}^k a_ib_{k - i}$$
					</div>

					<p>
						Note that this formula takes $O(n^2)$ time to compute $c_k$ for all $0 \leq k \leq 2n$, despite it only being $O(n)$ space of information. There seems to be a neat structure to the computation, so there's probably room for improvement by reusing calculations. This is where the Fast Fourier Transform comes in.
					</p>
				</div>
			</div>

			<div id="toc2" class="section">
				<div class="heading">Sampling and Interpolating</div>
				<div class="subsection">

					<p>
						A polynomial $f(x) = a_0 + \dots + a_nx^n$ can be represented by only its coefficients $a_0, \dots, a_n$. However, if we know its value at enough points, we can also determine the coefficients of the polynomial.
					</p>

					<div class="block">
						<div class="block-heading">Theorem</div>
Let $f(x) = a_0 + \dots + a_nx^n$ be a polynomial with degree $n$ whose coefficients $a_0, \dots, a_n$ are unknown. For any choice of distinct numbers $s_0, \dots, s_n$, if we know $f(s_0), \dots, f(s_n)$, then we can uniquely determine $a_0, \dots, a_n$.
					</div>

					<p>
						Let's call the choice of distinct numbers $s_0, \dots, s_n$ <i>sampling points</i> and the values of $f(s_0), \dots f(s_n)$ <i>samples</i>. Note that while the samples uniquely determine the coefficients, the samples themselves aren't unique because any choice of distinct sampling points will work.
					</p>

					<p>
						We call the process of calculating samples from the polynomial in coefficient form <i>sampling</i> and the process of determining the coefficients from samples <i>interpolating</i>.
					</p>
				</div>
			</div>

			<div id="toc3" class="section">
				<div class="heading">Speedup Overview</div>
				<div class="subsection">

					<p>
						For the sake of later convenience, we'll talk about multiplying polynomials of degree $n - 1$ from now on.
					</p>

					<p>
						Let $f(x) = a_0 + \dots + a_{n-1}x^{n-1}$ and $g(x) = b_0 + \dots + b_{n-1}x^{n-1}$ be polynomials of degree $n - 1$. Instead of multiplying them directly, we'll first sample both $f(x)$ and $g(x)$ at sample points $s_0, \dots, s_{2n - 1}$, calculating $f(s_0), \dots, f(s_{2n - 1})$ as well as $g(s_0), \dots, g(s_{2n - 1})$.
					</p>

					<p>
						Then we'll pointwise multiply the samples, calculating $f(s_0)g(s_0), \dots f(s_{2n - 1})g(s_{2n - 1})$. The theorem from the previous section tells us that this is enough to recover the coefficients of $f(x)g(x)$, since we have $2n$ samples and $f(x)g(x)$ is of degree $2n - 2$. Once we do that, we've calculated $f(x)g(x)$.
					</p>

					<p>
						If we can quickly sample and interpolate polynomials, then we can quickly multiply polynomials since the pointwise multiplication step only takes $O(N)$ time.
					</p>
				</div>
			</div>

			<div id="toc4" class="section">
				<div class="heading">Primitive Roots of Unity</div>
				<div class="subsection">

					<p>
						We have the luxury of picking whichever $2n$ sample points $s_0, \dots s_{2n - 1}$ we want, but if we want both sampling and interpolation to be fast, we better pick sample points that allow us to reuse calculations.
					</p>

					<p>
						A certain type of number that will allow us to do this is the primitive roots of unity.
					</p>

					<div class="block">
						<div class="block-heading">Definition</div>
A number $\om$ is said to be an $n$-th root of unity (for some positive integer $n$) if $\om^n =1 $.
<br/>
In particular, a $n$-th root of unity $\om$ is said to be <i>primitive</i> if for all $0 < k < n$, $\om^k \neq 1$.
					</div>
				</div>
			</div>

		</div>
	</body>
</html>