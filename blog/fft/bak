#site-title Fast Fourier Transform
#title The Fast Fourier Transform in Competitive Programming
#toc

#main

#section Introduction
In competitive programming, the Fast Fourier Transform is a technique that speeds up polynomial multiplication from $O(N^2)$ to $O( N \log N)$. In this article, we will explore the basic concepts behind this speedup and its implementation and applications.
#end section

#section Multiplying Polynomials
First, let's recap what a polynomial is:
#block Defintion
A polynomial $f(x)$ of degree $n$ is defined as $$f(x) = a_0 + a_1x + a_2x^2 + \dots + a_nx^n$$
where $a_0, \dots, a_n$ are numbers.
#end block
By convention, it's common to include the restriction $a_n \neq 0$, since if $a_n = 0$, it's becomes a polynomial with degree $n - 1$. For later convenience, we won't introduce this restriction.

We can multiply polynomials to get a new polynomial. Suppose $f(x) = a_0 + a_1 + \dots + a_nx^n$ and $g(x) = b_0 + b_1 + \dots + b_nx^n$ are both polynomials of degree $n$. Let $h(x) = f(x)g(x)$ be their product. We can calculate $h(x)$ by distributing and collecting the terms:
$$\begin{align} h(x) &= f(x)g(x) \\ &= (a_0 + a_1x + \dots + a_nx^n)(b_0 + b_1x + \dots + b_nx^n) \\ &= a_0(b_0 + b_1x + \dots + b_nx^n) + a_1x(b_0 + b_1x + \dots + b_nx^n) + \dots + a_nx^n(b_0 + b_1x + \dots + b_nx^n)\\ &=(a_0b_0 + a_0b_1x + \dots + a_0b_nx^n)+(a_1b_0x+a_1b_1x^2+\dots+a_1b_nx^{n+1})+(a_nb_0x^n+a_nb_1x^{n+1}+\dots+a_nb_nx^{2n})\\&=\sum_{i=0}^n\sum_{j=0}^na_ib_jx^{i+j}\end{align}$$

We can see that $h(x)$ is just the sum of all products of pairs $(a_ix^i)(b_jx^j) = a_ib_jx^{i+j}$ for all $i \in \{0,1,\dots,n\}$ and $j \in \{0,1,\dots,n\}$.

Since $f(x)$ and $g(x)$ are polynomials of degree $n$, the maximum degree of $h(x) = f(x)g(x)$ is $n + n = 2n$. Therefore, $h(x)$ is a polynomial of degree $2n$ which can be expressed as $h(x) = c_0 + c_1x + c_2x^2 + \dots + c_{2n}x^{2n}$.

Since $h(x)$ is a polynomial, it's determined by its coefficients $c_0, \dots, c_{2n}$, so we're interested in a formula to determine these coefficients. Note that for any $0 \leq k \leq 2n$, the only terms that contribute to the coefficient on $x^k$ are products of $a_ib_jx^{i+j}$ when $i + j = k$, so we get the formula

$$c_k = \sum_{i = 0}^n\sum_{j = 0}^n \begin{cases} a_ib_j & \text{ if } i + j = k \\ 0 & \text{otherwise}\end{cases}$$

We can simplify this further to

$$c_k = \sum_{i = 0}^k a_ib_{k - i}$$

This works since we loop through all possible values of $i$ and force $i + j = k$ by setting $j = k - i$. In summary,

#block Polynomial Mutliplication Formula
If $$\begin{align}f(x) &= a_0 + a_1x + \dots + a_nx^n\\g(x) &= b_0 + b_1x + \dots + a_nx^n \\h(x) = f(x)g(x) &= c_0 + c_1x + \dots + c_{2n}x^{2n}\end{align}$$then for all $0 \leq k \leq 2n$,
$$c_k = \sum_{i = 0}^k a_ib_{k - i}$$
#end block

Note that this formula takes $O(n^2)$ time to compute $c_k$ for all $0 \leq k \leq 2n$, despite it only being $O(n)$ space of information. There seems to be a neat structure to the calculations, so there's room for improvement by reusing calculations. This is where the Fast Fourier Transform comes in.
#end section

#section Basic Applications
The most basic application of multiplying polynomials is multiplying large numbers. Suppose we wish to multiply two numbers $A$ with digits $a_0a_1a_2\dots a_n$ and $B$ with digits $b_0b_1b_2\dots b_n$. 
We can choose two polynomials $f(x) = a_n + a_{n-1}x + \dots a_0x^n$ representing the number $A$ and $g(x) = b_n + b_{n-1}x + \dots + b_0x^n$ representing $B$. Note that $$f(10) = a_n + a_{n-1}(10) + \dots + a_0(10)^n = A \\ g(10) = b_n + b_{n-1}(10) + \dots + b_0(10)^n = B$$

 If we find their product $h(x) = f(x)g(x) = c_0 + c_1x + \dots +a_nx^n$, the product of numbers $A \times B$ is just equal to $h(10) = c_0 + c_1(10) + \dots c_{2n}(10)^{2n}$.

<hr/>

Another application of multiplying polynomials is solving a problem in combinatorics. Suppose there are two people, Alice and Bob, who are playing a game. For $0 \leq i \leq n$, Alice has $a_i$ ways to score $i$ points and for $0 \leq j \leq n$, Bob has $b_j$ ways to score $j$ points. For all $0 \leq k \leq 2n$, in how many ways can Alice and Bob score $k$ points in total?

Let $c_k$ be the number of ways Alice and Bob can score in total. We note that by definition, we want the sum of all products $a_ib_j$ where $i + j = k$. This means that this problem is exactly the problem of polynomial multiplication.
#end section

#section Sampling and Interpolating
A polynomial $f(x) = a_0 + \dots + a_nx^n$ can be represented by only its coefficients $a_0, \dots, a_n$. However, if we know its value at enough points, we can also determine the coefficients of the polynomial.
#block Theorem
Let $f(x) = a_0 + \dots + a_nx^n$ be a polynomial with degree $n$ whose coefficients $a_0, \dots, a_n$ are unknown. For any choice of distinct numbers $s_0, \dots, s_n$, if we know $f(s_0), \dots, f(s_n)$, then we can uniquely determine $a_0, \dots, a_n$.
#end block
Let's call the choice of distinct numbers $s_0, \dots, s_n$ <b>sampling points</b> and the values of $f(s_0), \dots f(s_n)$ <b>samples</b>. Note that while the samples uniquely determine the coefficients, the samples themselves aren't unique because any choice of distinct sampling points will work.

We call the process of calculating samples from the polynomial in coefficient form <b>sampling</b> and the process of determining the coefficients from samples <b>interpolating</b>.
#end section

#section Algorithm Overview

#end section

#end main
