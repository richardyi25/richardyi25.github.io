<!-- TODO : j = 0, not j = 1, fix the f(x), f[x], f_x notation -->
<!-- maybe normalize the section names -->
<!-- also, make some sections less wordy -->
<!-- fix the awful title tags for all sites -->

<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>1D1D DP: A Dynamic Programming Optimization</title>
		<link rel="stylesheet" href="prism.css">
		<link rel="stylesheet" href="style.css">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
		<script src="prism.js"></script>
	</head>

	<body>
		<div id="preamble">
			\[
				\DeclareMathOperator*{\argmax}{argmax}
			\]
		</div>

		<div id="title">
			1D1D DP: A Dynamic Programming Optimization
		</div>

		<div id="toc">
			<div class="heading">Table of Contents</div>
			<ul>
				<li><a href="#intro">Introduction</a></li>
				<li><a href="#prereq">Pre-Requisites</a></li>
				<li><a href="#motivation">Motivation Problem</a></li>
				<li><a href="#relation">General Form</a></li>
				<li><a href="#quad">Quadrangle Inequality</a></li>
				<li><a href="#mono">Monotonic Property</a></li>
				<li><a href="#o_nsquared">O(N²) Technique</a></li>
				<li><a href="#o_nlogn">O(N log N) Technique</a></li>
				<li><a href="#o_n">O(N) Technique</a></li>
				<li><a href="#cht">Relation to the Convex Hull Trick</li>
				<li><a href="#recognize">Recognizing the Quadrangle Inequality</li>
				<li><a href="#appendix">Appendix</a></li>
			</ul>
		</div>

		<div id="body">
			<div id="prereq">
				<div class="heading">Introduction</div>
				<div class="content">
					<p>
						1D1D DP, also known as the Slope Trick, is a dynamic programming optimization that
						reduces a specific type of \( O(N^2) \) DP solutions to \( O(N) \) or \( O(N \log N) \). 
						This is a well-known technique that is documented in English primarily in
						<a href="https://sites.google.com/site/ubcprogrammingteam/news/1d1ddynamicprogrammingoptimization-parti">this article</a>
						and <a href="https://codeforces.com/blog/entry/8219?#comment-139241">this comment</a> on a Codeforces blog post.
						This is one of many techniques that can be used to lower the time complexity of a DP recurrence that
						satisfies specific properties.
					</p>

					<p>
						The purpose of this article is to combine all information into one source and also provide reasoning
						behind the correctness of the technique.
					</p>
				</div>
			</div>

			<div id="prereq">
				<div class="heading">Pre-Requisite Knowledge</div>
				<div class="content">
					This article will assume you know about the following:
					<ul>
						<li>Time Complexity</li>
						<li>Prefix Sum Array</li>
						<li>Basic Dynamic Programming</li>
						<li>Binary Search</li>
						<li>Deque</li>
					</ul>

					<!-- TODO a[i] vs f(i), and also do you use subscripts, and one-letter array/funcs maybe? -->
					
					<p>
						To review math notation, the \( \max \) operator works like \( \sum \), except instead of summing
						the value to the right in all iterations, the maximum value across all iterations is taken.
						The \( \argmax \) operator is similar, but it instead represents the value of the iterated variable
						that yields the maximum.
					</p>

					<p>
						Additionally, the \( \forall \) symbol means "for all", the \( \exists \) symbol means "there exists", and
						the \( \nexists \) symbol means "there does not exist".

						For example, the statement \( \forall x, \exists y \gt x: f(x, y) = 1 \) should read as "For all \( x \),
						there exists some \( y \gt x \) such that \( f(x, y) = 1 \).
					</p>
				</div>
			</div>

			<div id="motivation" class="section">
				<div class="heading">A Motivation Problem</div>
				<div class="content">
					<p>
						Possibly the most classic problem where this technique can be applied is
						<a href="https://dmoj.ca/problem/apio10p1">Commando</a> from the APIO.
					</p>

					<p>
						To summarize the problem statement: Given an array of \( N \) positive numbers, \( (N \leq 10^6) \), partition it into any number of contiguous subarrays.
						The cost for each subarray is as follows: if \( x \) is the sum of the elements in the subarray,
						the cost is \( Ax^2 + Bx + C \) where \( A \lt 0 \) and \( A \), \(B  \),
						and \( C \) are given constants.
						The total cost is the sum of costs of the subarrays that the array is partitioned into.
						Find the maximum possible total cost.
					</p>

					<p>
						For the rest of the article, 1-index notation will be used, i.e. the indexes start from \( 1 \) and
						end in \( N \). The array in the problem will be referred to as \( arr[] \).
					</p>
				</div>
			</div>

			<div id="naive">
				<div class="heading">Naive Solution</div>
				<div class="content">
					<p>
						A naive DP solution emerges. Let \( dp[i] \) be the maximum possible cost if the array only contained the
						first \( i \) elements. Then, the answer to \( dp[i] \) is to pick some \( j \lt i \) and take the
						subarray beginning at \( j + 1 \) and ending at \( i \) as a partition and use the previously
						calculated \( dp[j] \) which tells us how to partition the rest of the array.
						It is uncertain which \( j \) will give the maximum value for \( dp[i] \)
						so all of them need to be tried out.

						In math notation, this is expressed as
						\[
							dp[i] = \max_{j = 1}^{i - 1} \left[ dp[j] + A \cdot s(j + 1, j)^2 + B \cdot s(j + 1, i) + C \right]
						\]
						where \( s(j + 1, i) \) is the of the elements of \( arr \) from \( j + i \) to \( i \), inclusive.
					</p>

					<p>
						To speed things up, a <a href="https://archive.mcpt.ca/cpt-lessons/data-structures/prefix-sum-array/">prefix sum array</a> can be used.
						Let \( psa[i] \) be the sum of all elements from \( 1 \) to \( i \) inclusive.
						Note that the sum from \( j + 1 \) to \( i \) is given by \( psa[i] - psa[j] \).
						The recurrence is rewritten as:
						\[
							dp[i] = \max_{j = 1}^{i - 1} \left[ dp[j] + A(psa[i] - psa[j])^2 + B(psa[i] - psa[j]) + C \right]
						\]
						The time complexity is \( O(N^2) \) because there are \( O(N) \) states, which each rely on \( O(N) \)
						previous states.
					</p>
					
					<p>
						Below is a C++ implementation.  The important DP part is highlighted.
					</p>

					<pre class="line-numbers" data-line="16-23"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long int lli;
const int MN = 1e6+1;
const lli INF = 1e18;
lli N, A, B, C, arr[MN], psa[MN], dp[MN];

int main(){
	scanf("%lld %lld %lld %lld", &N, &A, &B, &C);
	for(int i = 1; i <= N; i++){
		scanf("%lld", &arr[i]);
		psa[i] = psa[i - 1] + arr[i];
	}

	for(int i = 1; i <= N; i++){
		lli best = -INF;
		for(int j = 0; j < i; j++){
			lli val = dp[j] + A*(psa[i] - psa[j])*(psa[i] - psa[j]) + B*(psa[i] - psa[j]) + C;
			best = max(best, val);
		}
		dp[i] = best;
	}

	printf("%lld\n", dp[N]);
}</code></pre>
					<p>
						A time complexity of \( O(N^2) \) won't be able to pass a problem with \( N \leq 10^6 \). 1D1D DP
						optimizes the time complexity to \( O(N \log N) \) or \( O(N) \) which let the solution pass.
					</p>
				</div>
			</div>

			<div id="relation" class="section">
				<div class="heading">General Form</div>
				<div class="content">
					<p>
						The name 1D1D refers to a dynamic programming recurrence relation with one dimension (1D) of states
						which each rely on one dimension (1D) states.
					</p>

					<p>
						The recurrence relation from the motivation problem can be generalized to all relations that
						satisfy the form
						<div class="block">
							<div class="block-heading">General Form</div>
							\[
								dp[i] = \max_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
							\]
						</div>
						where \( f(i, j) \) is some "cost" or "weight" function associated with both \( i \) and \( j \).
						For example, in the motivation problem, \( f(i, j) = A(psa[i] - psa[j])^2 + (psa[i] - psa[j]) + C \).
					</p>
				</div>
			</div>

			<div id="quad" class="section">
				<div class="heading">The Quadrangle Inequality</div>
				<div class="content">
					Recall that the general recurrence relation for 1D1D DP is 
					\[
						dp[i] = \max_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
					\]
					The Quadrangle Inequality is a property of \( f(i, j) \), which if satisfied, implies two other
					properties: the Monotonic Property and the Turning Point Property.
					<div class="block">
						<div class="block-heading">Quadrangle Inequality</div>
						\[
							\forall j \lt i,
							f(i, j) + f(i + 1, j + 1) \leq f(i + 1, j) + f(i, j + 1)
						\]
					</div>

					<p>
						The restriction that \( j \lt i \) is because so the only time \( f(i, j) \) is used is when \( j \lt i \).
					</p>

					<p>
						This form of the inequality is the most common in literature but not very useful. If rearranged into
						\( f(i + 1, j + 1) - f(i + 1, j) \leq f(i, j + 1) - f(i, j) \),
						then it gives the intuition that as \( i \) increases, the rate of change of \( f(i, j) \) in respect to \( j \) increases.
					</p>

					<p>
						If rearranged like into \( f(i + 1, j + 1) - f(i, j + 1) \leq f(i + 1, j) - f(i, j) \),
						then it gives the intuition that as \( j \) increases, the rate of change of \( f(i, j) \) in respect to \( i \) increases.
					</p>

					<p>
						Because as one thing increases, the rate of change of something increases, the Quadrangle Inequality
						is sometimes referred to as \( f(i, j) \) being convex or concave.
					</p>

					<p>
						This is also written in the form
						\[
							\forall j \lt j' \lt i \lt i', f(i, j) + f(i', j') \leq f(i', j) + f(i, j')
						\]
						The statement given above is a specific case of this more general case where \( i' = i + 1 \) and \( j' = j + 1 \).
					</p>
				</div>
			</div>

			<div id="mono" class="section">
				<div class="heading">Monotonic Property</div>
				<div class="content">
					<p>
						The first thing that the Quadrangle Inequality implies is the Montonic Property.
					</p>

					<p>
						Recall that the general recurrence relation for 1D1D DP is 
						\[
							dp[i] = \min_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
						\]
						Let's define \( opt(i) \) to be the value of \( j \) that you use to in order to compute
						the value of \( dp[i] \), i.e. the value of \( j (j \lt i) \) for which \( dp[j] + f(i, j) \)
						is minimized. (The \( opt \) comes from "optimal"). We can write this in math notation as
						<div class="block">
							<div class="block-heading">
								Definition of \( opt(i) \)
							</div>
							\[
								opt(i) = \argmax_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
							\]
						</div>
						The <b>Monotonic Property</b> is satisfied if as \( i \) increases, \( opt(i) \) does not decrease.
					</p>

					<p>
						This can be expressed in math notation in two equivalent statements:

						<div class="block">
							<div class="block-heading">Monotonic Property</div>
							\[
								\forall i, opt(i) \leq opt(i + 1)
							\]
							<center>or<center>
							\[
							   \forall i \lt i', opt(i) \leq opt(i')
							\]
						</div>
					</p>

					<p>
						You can read the proof that the Quadrangle Inequality proves the Monotonic Property <a href="proof1.html">here</a>.
					</p>
				</div>
			</div>

			<div id="turning" class="section">
				<div class="heading">Turning Point Property</div>
				<div class="content">
					<p>
						The second property that the Quadrangle Inequality implies is the Turning Point Property.
					</p>

					<p>
						The Turning Point Property is satisfied if for all \( j \lt j' \), there exists a singular \( i \)
						such that for all indexes \( \leq i \), it is better to use \( j \) than \( j' \), i.e.
						\( dp[j] + f(i, j) \gt dp[j'] + f(i, j') \) but for all indexes \( \gt i \), it is better to use
						\( j' \) than \( j \), i.e. \( dp[j'] + f(i, j') \gt dp[j] + f(i, j) \).
					</p>

					<p>
						Note that the \( i \) can approach positive or negative infinity without bounds, meaning that if
						\( j \) is always better or worse than \( j' \), the property is still satisfied.
					</p>

					<p>
						Therefore, a more proper formulation states that the Turning Point Property is satisfied if
						for all \( j \lt k \), there <b>doesn't</b> exist some \( i \lt i' \) where \( j' \) is better at
						\( i \) but \( j \) is better at \( j' \), i.e. \( dp[j'] + f(i, j') \gt dp[j] + f(i, j) \) but
						\( dp[j] + f(i', j) \gt dp[j'] + f(i', j) \).
					</p>

					<p>
						This can be written in math notation as:
						<div class="block">
							<div class="block-heading">Turning Point Property</div>
							\[
								\forall j \lt j', \nexists i \lt i':
								\\
								\begin{align}
									dp[j'] + f(i, j') & \gt dp[j] + f(i, j)
									\\
									dp[j] + f(i', j) & \gt dp[j'] + f(i', j)
								\end{align}
							\]
						</div>
					</p>
				</div>
			</div>

			<div id="o_nsquared" class="section">
				<div class="heading">The O(N²) Technique</div>
				<div class="content">
					<p>
						Since we know that \( opt(i) \) doesn't decrease, we can keep track of \( opt(i - 1) \) in a variable and instead of calculating
						\[
							dp[i] = \min_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
						\]
						we can make a small change and calculate
						\[
							dp[i] = \min_{j = opt(i - 1)}^{i - 1} \left[ d_j + f(i, j) \right]
						\]
						This solution is still \( O(N^2) \) and in the worst case, \( g(i) = 0 \) for all \( i \), but in practice, this will often
						be fast enough to pass.
					</p>

					<p>
						Below is a C++ implementation.  The important DP part is highlighted.
						<pre class="line-numbers" data-line="16-27"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long int lli;
const int MN = 1e6+1;
const lli INF = 1e18;
lli N, A, B, C, arr[MN], psa[MN], dp[MN];

int main(){
	scanf("%lld %lld %lld %lld", &N, &A, &B, &C);
	for(int i = 1; i <= N; i++){
		scanf("%lld", &arr[i]);
		psa[i] = psa[i - 1] + arr[i];
	}

	int opt = 0;
	for(int i = 1; i <= N; i++){
		lli best = -INF;
		for(int j = opt; j < i; j++){
			lli val = dp[j] + A*(psa[i] - psa[j])*(psa[i] - psa[j]) + B*(psa[i] - psa[j]) + C;
			if(val > best){
				best = val;
				opt = j;
			}
		}
		dp[i] = best;
	}

	printf("%lld\n", dp[N]);
}</code></pre>
						This code is enough to get full points on the official test data for APIO Commando.
					</p>
				</div>
			</div>

			<div id="o_nlogn" class="section">
				<div class="heading">The O(N log N) Technique</div>
				<div class="content">
					A sketch of the algorithm follows:
				</div>
			</div>

			<div id="o_n" class="section">
				<div class="heading">The O(N) Technique</div>
				<div class="content">
				</div>
			</div>

			<div id="cht" class="section">
				<div class="heading">Relation to the Convex Hull Trick</div>
				<div class="content">
					The Convex Hull Trick can be seen as a special case of 1D1D DP.
				</div>
			</div>

			<div id="recognize" class="section">
				<div class="heading">Recognizing the Quadrangle Inequality</div>
				<div class="content">
					<p>
						To illustrate how we can prove the Quadrangle Inequality for a recurrence, <a href="quad.html">here</a> is an example of an algebraic proof
						for the motivation problem, APIO Commando.
					</p>

					<p>
						While it is possible to write out, expand, and factor terms by hand on paper, it might be more viable,
						especially during contest, to abandon trying to prove the Quadrangle Inequality. Instead, the naive
						\( O(N^2) \) solution can be coded up, (not the optimzied version discussed in this article), and if the
						values of \( opt(i) \) can be printed out. If \( opt(i) \) does not decrease for several small test inputs,
						the Quandrangle Inequality is <i>probably</i> satisfied.
					</p>
				</div>
			</div>

			<div id="appendix" class="section">
				<div class="heading">Appendix</div>
				<div class="content">
					<p>
						This technique also works if you replace \( \min \) with \( \max \).
						<br>
						It applies to recurrences of the form
						\[
							d_i = \max_{j = 1}^{i - 1} \left[ d_j + f(i, j) \right]
						\]
						if and only if \( f(i, j) \) satisfies for all \( j \leq i \),
						\[
							f(i, j) + f(i + 1, j + 1) \geq f(i + 1, j) + f(i, j + 1)
						\]
					</p>

					<!-- TODO Restructure these blocks -->

					<hr/>

					<p>
						Proof that if
						\[
							\forall j < i,
							f(i, j) + f(i + 1, j + 1) \leq f(i + 1, j) + f(i, j + 1)
						\]
						<center>then</center>
						\[
							\forall j < j' < i < i', f(i, j) + f(i', j') \leq f(i', j) + f(i, j')
						\]
					</p>

					<p>
						<b>Lemma:</b> For all x, y and a > 0, \( f(x + 1, y + b) - f(x + 1, y) \leq f(x, y + b) - f(x, y) \)
						Using the rearrangement \( f(i + 1, j + 1) - f(i + 1, j) \leq f(i, j + 1) - f(i, j) \), this can be proven by induction.
					</p>

					<p>
						The base case, \( a = 1 \), directly follows by applying the Quadrangle Inequality for \( i = x, j = y \).
					</p>

					<p>
						In the induction step, for \( b > 1 \), if
						\[
							f(x + 1, y + b) - f(x + 1, y) \leq f(x, y + b) - f(x, y)
						\]
						<center>then</center>
						\[
							f(x + 1, y + b + 1) - f(x + 1, y) \leq f(x, y + b + 1) - f(x, y)
						\]
						This directly follows by applying the Quadrangle Inequality for \( i = x, j = y + b \).
					</p>

					<p>
						Now \( f(x + a, y + b) - f(x + a, y) \leq f(x, y + b) - f(x, y) \) can be proven.
					</p>

					<p>
						In the base case, \( a = 1 \), which directly follows from the lemma.
					</p>

					<p>
						In the induction step, for all \( a \gt 1\), if
						In the induction step, for \( b \gt 1 \), if
						\[
							f(x + a, y + b) - f(x + a, y) \leq f(x, y + b) - f(x, y)
						\]
						<center>then</center>
						\[
							f(x + a + 1, y + b) - f(x + a + 1, y) \leq f(x, y + b) - f(x, y)
						\]
						This directly follows by applying the lemma, for \( x = x + a, y = y \). \( \square \)
					</p>
				</div>
			</div>

			<!--

			<div id="template" class="section">
				<div class="heading">Template Heading</div>
				<div class="content"></div>
			</div>

			-->
		</div>
	</body>
</html>
